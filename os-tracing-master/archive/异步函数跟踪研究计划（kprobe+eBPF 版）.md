## 1 插桩阶段

### 确定函数插桩的方案

该方案需要满足以下要求：

1. 能够确认函数的调用和返回时间

2. 能够确认该函数在栈中的深度

3. 跟踪工具不会跟踪它本身（否则会死循环）

|**模块**|**功能描述**|**技术实现细节**|
|:----|:----|:----|
|**动态二进制插桩工具**|在目标程序的特定函数入口/出口插入探针，记录异步任务生命周期事件。|使用uftrace工具，依赖Linux的perf_event接口，支持动态插桩（运行时NOP指令替换）。|
|**上下文分类模型**|定义异步任务的执行上下文类型（任务、编译器生成、用户实现、匿名）。|基于Rust标准库和运行时API分析（如task::spawn、async/await生成的Future对象）。|

profile.sh

```bash
if [ "$3" = "async_std" ]; then
    uftrace record -P "_<async_std..task..builder..SupportTaskLocals<F> as core..future..future..Future>::poll::_{{closure}}" ... $1
elif [ "$3" = "tokio" ]; then
    uftrace record -P "tokio..runtime..blocking..task..BlockingTask<T> as core..future..future..Future" ... $1
fi
```
* **功能**：  

   * 根据运行时（`async_std`或`tokio`）选择插桩模式。  

   * 通过正则表达式匹配任务创建点（如`task::spawn`）、Future的`poll`方法入口/出口。  

   * 生成插桩后的二进制文件，记录跟踪数据到`.dat`文件。  

## 2 数据收集阶段

### 研究编译信息（符号表，debuginfo）

1. 将函数被调用或返回时的指令指针转换为函数签名

2. 将函数签名转换为源代码中的函数名

   * 例如，闭包的函数签名是 `{{closure}}`，如何反推回源代码？（我能想到的是zjp学长的函数签名版本工具）

   * 可能的思路：宏，修改rust编译参数，修改rust编译器


|**模块**|**功能描述**|**技术实现细节**|
|:----|:----|:----|
|**数据收集模块**|捕获时间戳、线程ID、函数名、上下文类型、栈深度等原始数据。|探针生成日志条目，缓冲至RAM磁盘避免I/O阻塞，支持跨线程异步写入。|

profile.sh

```bash
uftrace dump > dumped_data.txt
mv ./dumped_data.txt ./profile/
```
* **功能**：  

* 将二进制跟踪数据（`.dat`文件）转换为文本格式`dumped_data.txt`。  

* 包含函数调用事件（`entry`/`exit`）、时间戳、线程ID、栈深度等原始信息。  


---
## 3 数据处理阶段

### 内核执行流拆分

1. 基于内核 switch 函数，将内核执行流拆分为不同内核线程

2. 基于内核异步运行时信息，将内核线程执行流拆分为不同协程

|**模块**|**功能描述**|**技术实现细节**|
|:----|:----|:----|
|**栈回溯与数据处理**|解析嵌套异步任务的执行顺序和层级关系，计算任务执行时间。|通过栈推入/弹出操作关联入口和退出事件，生成任务时间区间（entry_ts - exit_ts）。|

parser.py

```python




# 状态机解析逻辑
for line in fp:
    if re.search("reading (.*).dat", line):
        thread_list.append(threads[0])  
    # 状态机逻辑解析每行数据...
 # 数据转换与JSON生成
def output_in_json(...):
    trace_events = []
    # 构建时间戳、线程ID、符号修饰等字段
    data = {"traceEvents": trace_events, "displayTimeUnit": "ms"} 
    jsonfile.write(json.dumps(data))
```
* **功能**：  

* **状态机解析**：通过正则表达式和状态变量（`find_task_state`）识别异步任务的创建、嵌套Future的`poll`调用。  

* **数据转换**：  

   * 时间戳转换为微秒级。  

   * 清理函数名（如替换`..`为`::`）。  

   * 通过栈深度和线程ID重建任务层级。  

* **可选功能**：通过`--get-location`参数调用`objdump`获取源码位置。  


---
## 4 可视化阶段

|**模块**|**功能描述**|**技术实现细节**|
|:----|:----|:----|
|**可视化工具链**|将结构化数据转换为时间线图，展示任务调度、阻塞事件和性能瓶颈。|使用Trace-viewer解析JSON格式日志，生成交互式时间线图。|

parser.py生成的JSON文件

```python
data = {"traceEvents": trace_events, "displayTimeUnit": "ms"} 
jsonfile.write(json.dumps(data))
```
* **功能**：  

   * 生成符合`Trace-viewer`格式的JSON文件。  

   * 时间线图展示：  

      * **水平条**：任务持续时间。  

      * **嵌套层级**：任务与Future的父子关系（如`Task A → Future B`）。  

      * **颜色标记**：阻塞事件（红色）、I/O操作（蓝色）。


---
## **不足**

* **无法区分任务实例**：无法准确识别不同任务实例，易导致分析结果不准确。

* **发布模式兼容性差**：在发布模式下跟踪进度不准确，影响用户对实际运行情况的判断。

* **性能开销仍需优化**：尽管采用了动态检测方法来减轻跟踪开销，但在某些场景下，如对性能要求极高的实时系统或大规模并发任务场景，现有的开销可能仍然会影响程序的正常运行。

* **无法处理组合子**：对join!和select!等组合子处理不当，影响性能分析。

* **解析记录速度慢**：解析和记录跟踪数据的速度慢，影响分析效率。

* **任务颜色标注混乱**：不同任务颜色标注混乱，影响分析体验。

* **位置信息错误**：因符号解析问题，部分位置信息错误，难以准确定位代码问题。

* **与第三方库集成**：探索将 CAT 与现有 Rust ⼯具集成的潜在⽅法，以提供⽆缝的 Rust 程序分析体验。

如果用于追踪ArceOS的异步：

* 没有对应的动态插桩工具，需要考虑静态插桩，包括异步函数创建，调度，执行，中断处理等过程。

* 同样可以根据不同异步操作分成不同异步上下文。

* 收集到数据后，状态机解析逻辑和可视化逻辑应该可以参考。


