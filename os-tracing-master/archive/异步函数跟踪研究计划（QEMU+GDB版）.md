## 0 软件栈

三选一：GDB脚本 / GDB Python 脚本 / 在 code-debug 插件上增加该功能

## 1 插桩阶段

### 1.1 获取“异步上下文函数”的符号

1.1.1 通过人工分析，找到生成 Task 和 Future 的函数 pattern

1.1.2 从符号表中过滤出符合这些 pattern 的函数名（可能需要demangle）

1.1.3 （可选，不知道怎么做）借助 debuginfo 将函数名还原回源代码中的函数

### 1.2 “异步上下文函数”插桩

1.2.1 在 1.1 中获取的函数名处设断点

1.2.2 当某个断点触发时，检测它是否为这些“异步上下文断点”。若是，则表示“异步上下文函数”触发了，进入数据收集阶段。

## 2 数据收集阶段

### 2.1 在 log 文件中记录 时间戳 + entry + 函数名 + 函数在栈中的深度（通过GDB自带的栈回溯功能）

### 2.2 在该“异步上下文函数”的返回指令处设断点

2.2.1 我想到的一种做法：在函数调用指令的下一个指令设断点即可

以下面这段伪汇编代码为例

```plain
call function_foo
do thing 1


function_foo:
do thing 2
ret
```
断点打在  `call function_foo` 可以检测到函数触发，函数执行完肯定返回到  `do thing 1` 指令，所以在  `do thing 1` 指令处设断点就可以检测到  `function_foo` 函数执行完毕。
### 2.3 继续执行，直到该“异步上下文函数”返回。

### 2.4 在 log 文件中记录 时间戳 + exit + 函数名 + 函数在栈中的深度（通过GDB自带的栈回溯功能）

## 3 数据处理阶段

### 3.1 内核执行流拆分

3.1.1 基于内核 switch 函数，将内核执行流拆分为不同内核线程

3.1.2 基于内核异步运行时信息，将内核线程执行流拆分为不同协程

|**模块**|**功能描述**|**技术实现细节**|
|:----|:----|:----|
|**栈回溯与数据处理**|解析嵌套异步任务的执行顺序和层级关系，计算任务执行时间。|通过栈推入/弹出操作关联入口和退出事件，生成任务时间区间（entry_ts - exit_ts）。|

parser.py

```python




# 状态机解析逻辑
for line in fp:
    if re.search("reading (.*).dat", line):
        thread_list.append(threads[0])  
    # 状态机逻辑解析每行数据...
 # 数据转换与JSON生成
def output_in_json(...):
    trace_events = []
    # 构建时间戳、线程ID、符号修饰等字段
    data = {"traceEvents": trace_events, "displayTimeUnit": "ms"} 
    jsonfile.write(json.dumps(data))
```
* **功能**：  

* **状态机解析**：通过正则表达式和状态变量（`find_task_state`）识别异步任务的创建、嵌套Future的`poll`调用。  

* **数据转换**：  

   * 时间戳转换为微秒级。  

   * 清理函数名（如替换`..`为`::`）。  

   * 通过栈深度和线程ID重建任务层级。  

* **可选功能**：通过`--get-location`参数调用`objdump`获取源码位置。  


---
## 4 可视化阶段

|**模块**|**功能描述**|**技术实现细节**|
|:----|:----|:----|
|**可视化工具链**|将结构化数据转换为时间线图，展示任务调度、阻塞事件和性能瓶颈。|使用Trace-viewer解析JSON格式日志，生成交互式时间线图。|

parser.py生成的JSON文件

```python
data = {"traceEvents": trace_events, "displayTimeUnit": "ms"} 
jsonfile.write(json.dumps(data))
```
* **功能**：  

   * 生成符合`Trace-viewer`格式的JSON文件。  

   * 时间线图展示：  

      * **水平条**：任务持续时间。  

      * **嵌套层级**：任务与Future的父子关系（如`Task A → Future B`）。  

      * **颜色标记**：阻塞事件（红色）、I/O操作（蓝色）。


---
## **不足**

* **无法区分任务实例**：无法准确识别不同任务实例，易导致分析结果不准确。

* **发布模式兼容性差**：在发布模式下跟踪进度不准确，影响用户对实际运行情况的判断。

* **性能开销仍需优化**：尽管采用了动态检测方法来减轻跟踪开销，但在某些场景下，如对性能要求极高的实时系统或大规模并发任务场景，现有的开销可能仍然会影响程序的正常运行。

* **无法处理组合子**：对join!和select!等组合子处理不当，影响性能分析。

* **解析记录速度慢**：解析和记录跟踪数据的速度慢，影响分析效率。

* **任务颜色标注混乱**：不同任务颜色标注混乱，影响分析体验。

* **位置信息错误**：因符号解析问题，部分位置信息错误，难以准确定位代码问题。

* **与第三方库集成**：探索将 CAT 与现有 Rust ⼯具集成的潜在⽅法，以提供⽆缝的 Rust 程序分析体验。

如果用于追踪ArceOS的异步：

* 没有对应的动态插桩工具，需要考虑静态插桩，包括异步函数创建，调度，执行，中断处理等过程。

* 同样可以根据不同异步操作分成不同异步上下文。

* 收集到数据后，状态机解析逻辑和可视化逻辑应该可以参考。

## 


