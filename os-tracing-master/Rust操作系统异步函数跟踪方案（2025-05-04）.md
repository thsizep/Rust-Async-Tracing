# Rust操作系统异步函数跟踪方案（2025-05-04）

## 1. 概述

Rust 在不进行换栈等上下文切换的情况下实现了异步执行流。实现的方法是，在编译的过程中，在用户标注的帮助下，异步函数被切割成若干个同步函数。因此只要我们能跟踪这些同步函数，就可以还原出异步函数的执行情况。

## 2. 相关工作

### 2.1 Rust 语言的异步语法

在 Rust 语言中, 异步函数的编写和调用是分离的.

编写异步函数的方法是编写 Future 结构体, 将异步代码放在 Future 结构体内的 poll 函数中. 当然, 开发者也可以用`async fn`等语法糖让编译器代替他生成 Future 结构体.

调用异步函数的方法是 `await` 标签. 这个标签的意思是 "阻塞当前执行流, 当调用的异步代码完成执行后, 恢复执行流". 

调用了异步函数的函数也是异步函数. 最顶层（入度为0的）的异步函数同时也是 task. 

### 2.2 Rust 编译器对异步函数的改造

异步函数内的执行流可以被阻塞和恢复, 而常规函数是做不到的. 

对于这个问题, 其他语言的解决方案是

- 用轮询代替执行流的阻塞/恢复. 缺点：低效.
- 支持常规函数内换栈. 缺点：每种 ISA 的换栈代码都不同，不跨平台.

而 Rust 语言的解决方案是: 

- 将异步函数的机器代码以 **阻塞/恢复点** （即 `await` 标签） 为界限分割成若干个不含 执行流阻塞/恢复 的常规函数.
- 这些常规函数被注册到由用户提供的异步运行时中，由异步运行时主动进行调用.
- 这些常规函数的返回值有统一的标准，从而异步运行时能得知这个阻塞/恢复点是否通过（即`await`的异步代码是否完成）. 通过的话会提取出返回值里异步任务的返回值并传递给下一个常规函数, 不通过的话会稍后再次调用同一个常规函数.

### 2.3 论文的工作（利用符号表进行异步函数跟踪）

> 论文 pdf 在 archive/ 文件夹里

_CAT: Context Aware Tracing for Rust Asynchronous Programs_ 这篇论文所作的工作是: 论文的作者发现被拆分出的常规函数的函数名是有规律的（这个规律简单来说就是至少包含 `future`, `poll`, `closure` 三个关键字中的一个）, 因此他们对函数名符合这个规律的函数都进行插桩, 记录这些函数的调用和返回时间，进而画出异步任务的火焰图. 

有一些和异步任务无关的函数恰巧也符合上述规律, 作者们采用了一个算法将这种函数过滤掉. 

> 这个算法在论文里没有说明, 我从论文附带的代码中还原出了这个算法的文字描述. 见 <https://github.com/chenzhiy2001/os-tracing/discussions/23#discussioncomment-12929682>.

该论文的缺陷是画出来的火焰图形如`___/Future1\____/Future2\___/Future1\___`，所有Future的调用信息都挤在同一行. 如果每一行是一个Future的调用信息的话会更好. 

### 2.4 石尚峰学长的工作（利用dwarf调试信息进行异步函数跟踪）

> 链接： <https://cubele.github.io/probe-docs/async-probe/>

石尚峰学长的工作是分析了编译后生成的dwarf调试信息, 发现一个异步函数在dwarf调试信息里被表示为一个结构体, 且结构体内明确写出了这个异步函数对应的future会调用哪些future. 但是用户自己实现的 future 并不会被记录在这些结构体里, 因此作者建议先静态分析 dwarf 调试信息, 得到 future 依赖树. 该树的叶子节点很可能包含用户自定义的 future, 因此对叶子 future 的 poll 函数和 closure 函数进行动态插桩, 从而获得足够多的异步函数执行信息（因为对用户debug有用的阻塞发生在叶子future里）.

但是石尚峰学长没有用代码完整实现这个思路, 原因是zCore内没有 jprobe 插桩工具：

```
如果真的要做到完整的动态插桩，加入编译器支持以后使用jprobe应该是最可行的做法。具体来说我们要知道async函数生成的Future里面的poll函数的地址以及具体的参数类型（状态机对应的struct结构），然后在对应的地址插入jprobe直接访问这个struct，从而每次poll以后struct更新的状态都可以直接看到。

现在不能实现的原因是：

- 目前这个struct的结构只有在编译后才可以看到，可能要用别的手段实现jprobe的handler

- async函数生成的poll函数的地址在debuginfo里面不太好找，需要编译器支持

- rust想要实现jprobe可能会比较复杂。
```

但是我想到我们可以用 gdb 代替 jprobe 插桩工具.

### 2.5 lilos async rust debugger

> 链接：<https://cliffle.com/blog/async-decl-coords/>

在 dwarf 调试信息中, 异步函数被表示成形如 `{async_fn_env#0}` 的形式. 该博客解释了如何将它对应回源代码文件名和行号.


### 3. 设计

我的思路综合了以上他人工作, 通过静态分析（dwarf）和动态插桩（gdb）结合, 进行异步函数的跟踪调试：

1. 被调试程序启动前, 基于石尚峰学长的思路静态分析 dwarf 调试信息文件, 在调试界面中显示 future 树
    1. 利用 lilos async rust debugger 的方法, 将调试界面的 future 树中形如 `{async_fn_env#0}` 的标签还原回源代码位置
2. 被调试程序启动后, 基于论文的思路, 用 gdb 对 future 树的叶子节点对应的 `poll` `closure` `等函数进行动态插桩 
3. 利用论文提供的的可视化方法, 画出这些 future 的火焰图, 显示在调试界面 future 树节点的附近

这样的话，我们能跟踪 async fn + 自己 impl future 了。
这样做的优点是不需要宏。
缺点是内联的 poll 和 closure 函数无法跟踪。

### 4. 实现

#### 4.1 future依赖树
在dwarf中递归查找即可。参考 <https://github.com/cubele/rust-async-tree-parser>
#### 4.2 叶子 future 动态跟踪:
##### 4.2.1 函数名关键词过滤
考虑到论文中提到的四种 async 函数都带 poll 字眼， 过滤 poll.
##### 4.2.2 设断点
函数开头的断点的让gdb在debugee运行前设。
函数末尾的断点让gdb在函数头断点触发之后运行 finish 命令。（finish 命令的原理和栈帧有关，暂时没弄清）
##### 4.2.3 设断点时收集数据
future定位：依靠 self 指针

时间：GDB自带支持，可能需要去除进入gdb处理的时间

pid tid 有两种方案：
- 依靠异步运行时的“钩子断点”支持
- 直接抓取内存地址

poll结果：依靠收集返回值进行判断（gdb支持获取函数返回值，原理暂时没弄清）
##### 4.2.4 过滤无关同步函数
根据论文中的算法

##### 4.2.5 画图
生成符合 [Trace Event Format](https://docs.google.com/document/d/1CvAClvFfyA5R-PhYUmn5OOQtYMH4h6I0nSsKchNAySU/preview?tab=t.0#heading=h.yr4qxyxotyw) 的json，然后放入 chrome://profiling 

### 5. 例子
见仓库 `example` 文件夹